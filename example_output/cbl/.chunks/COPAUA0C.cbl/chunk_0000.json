{
  "batch_idx": 0,
  "total_batches": 5,
  "template": {
    "header": {
      "program_id": "COPAUA0C",
      "file_name": "COPAUA0C.cbl",
      "file_type": "COBOL",
      "analyzed_by": "WAR_RIG",
      "analyzed_at": "2026-02-24T17:32:50.709459",
      "iteration_count": 1,
      "final_status": null
    },
    "purpose": {
      "summary": "COPAUA0C is a CICS COBOL program that processes authorization requests from a message queue, interacts with IMS, and sends responses. It retrieves messages from a request queue, processes them, and updates relevant systems before terminating.",
      "business_context": "Authorization processing within a financial transaction system.",
      "program_type": "ONLINE_CICS",
      "citations": [
        3,
        6,
        7
      ]
    },
    "inputs": [
      {
        "name": "MQTM",
        "io_type": "CICS_COMMAREA",
        "description": "Message Queue Trigger Monitor data containing the request queue name and trigger data.",
        "copybook": null,
        "citation": [
          16,
          20,
          21
        ]
      },
      {
        "name": "REQUEST-QUEUE",
        "io_type": "CICS_QUEUE",
        "description": "The WebSphere MQ queue from which authorization requests are read.",
        "copybook": null,
        "citation": [
          26,
          37
        ]
      }
    ],
    "outputs": [
      {
        "name": "RESPONSE-QUEUE",
        "io_type": "CICS_QUEUE",
        "description": "The WebSphere MQ queue to which authorization responses are written. Details of the response structure are not evident in the provided code snippet.",
        "copybook": null,
        "citation": []
      },
      {
        "name": "IMS",
        "io_type": "IMS_SEGMENT",
        "description": "Updates to IMS database segments related to authorization processing. The specific segments updated are not evident in the provided code snippet.",
        "copybook": null,
        "citation": []
      }
    ],
    "called_programs": [
      {
        "program_name": "MQOPEN",
        "call_type": "STATIC_CALL",
        "purpose": "Opens the request message queue.",
        "parameters": [
          "W01-HCONN-REQUEST",
          "MQM-OD-REQUEST",
          "WS-OPTIONS",
          "W01-HOBJ-REQUEST",
          "WS-COMPCODE",
          "WS-REASON"
        ],
        "citation": 41
      }
    ],
    "calling_context": {
      "called_by": [],
      "entry_points": [],
      "linkage_section": []
    },
    "business_rules": [
      {
        "rule_id": "BR001",
        "description": "The program processes messages from the request queue until either no more messages are available or a loop end condition is met.",
        "logic_summary": "The PERFORM UNTIL loop continues as long as NO-MORE-MSG-AVAILABLE is false and WS-LOOP-END is false.",
        "conditions": [
          "NO-MORE-MSG-AVAILABLE",
          "WS-LOOP-END"
        ],
        "citation": [
          103
        ]
      },
      {
        "rule_id": "BR002",
        "description": "The program limits the number of messages processed in a single execution.",
        "logic_summary": "The program checks if WS-MSG-PROCESSED exceeds WS-REQSTS-PROCESS-LIMIT. If it does, WS-LOOP-END is set to TRUE, terminating the processing loop.",
        "conditions": [
          "WS-MSG-PROCESSED > WS-REQSTS-PROCESS-LIMIT"
        ],
        "citation": [
          116,
          117
        ]
      }
    ],
    "data_flow": {
      "reads_from": [
        {
          "source": "MQTM",
          "fields_used": [
            "MQTM-QNAME",
            "MQTM-TRIGGERDATA"
          ],
          "citation": [
            16,
            20,
            21
          ]
        },
        {
          "source": "REQUEST-QUEUE",
          "fields_used": [
            "Authorization Request Message"
          ],
          "citation": [
            26,
            37
          ]
        }
      ],
      "writes_to": [
        {
          "destination": "RESPONSE-QUEUE",
          "fields_written": [
            "Authorization Response Message"
          ],
          "citation": []
        },
        {
          "destination": "IMS",
          "fields_written": [
            "Updated IMS Segments"
          ],
          "citation": []
        }
      ],
      "transforms": [
        {
          "input_field": "MQTM-QNAME",
          "output_field": "WS-REQUEST-QNAME",
          "transformation_description": "The queue name from the trigger monitor message is moved to the working storage variable WS-REQUEST-QNAME.",
          "citation": [
            20
          ]
        },
        {
          "input_field": "MQTM-TRIGGERDATA",
          "output_field": "WS-TRIGGER-DATA",
          "transformation_description": "The trigger data from the trigger monitor message is moved to the working storage variable WS-TRIGGER-DATA.",
          "citation": [
            21
          ]
        }
      ]
    },
    "copybooks_used": [],
    "paragraphs": [
      {
        "paragraph_name": "COPAUA0C",
        "summary": null,
        "purpose": "This is the program identifier. It does not contain any executable code. It serves as a label to identify the COPAUA0C program within the system. This paragraph does not directly consume any inputs or produce any outputs. It is the starting point for the program's execution, but it immediately passes control to other paragraphs. No business logic or error handling is present in this paragraph. It calls other paragraphs to perform the actual processing.",
        "called_by": [],
        "calls": [
          "CMQODV",
          "CMQMDV",
          "CMQODV",
          "CMQMDV",
          "CMQV"
        ],
        "citation": [
          23,
          23
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "MAIN-PARA",
        "summary": null,
        "purpose": "This paragraph serves as the main control flow for the COPAUA0C program. It orchestrates the initialization, main processing, and termination steps. First, it performs 1000-INITIALIZE to set up the environment and open the necessary resources. Then, it performs 2000-MAIN-PROCESS to handle the core authorization processing logic. Finally, it performs 9000-TERMINATE to close resources and clean up before exiting. The paragraph does not directly consume any input data, but it relies on the initialization step to prepare the environment. It also does not directly produce any output, but it triggers the main processing and termination steps that generate outputs. This paragraph contains no business logic or error handling itself, but it calls other paragraphs that implement these functions. After the termination step, the program returns to CICS.",
        "called_by": [],
        "calls": [
          "1000-INITIALIZE",
          "2000-MAIN-PROCESS",
          "9000-TERMINATE"
        ],
        "citation": [
          220,
          229
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1000-INITIALIZE",
        "summary": null,
        "purpose": "This paragraph initializes the program environment by retrieving MQ trigger monitor data and opening the request queue. It starts by retrieving the MQTM data using EXEC CICS RETRIEVE, which contains the queue name (MQTM-QNAME) and trigger data (MQTM-TRIGGERDATA). These values are then moved to working storage variables WS-REQUEST-QNAME and WS-TRIGGER-DATA, respectively. A wait interval of 5000 is set in WS-WAIT-INTERVAL. Next, it calls 1100-OPEN-REQUEST-QUEUE to open the request queue and 3100-READ-REQUEST-MQ to read the first request message. The paragraph consumes MQTM data as input and prepares the environment for further processing. It does not produce any direct output but sets up the necessary resources. The paragraph checks if the CICS RETRIEVE command was successful (EIBRESP = DFHRESP(NORMAL)). If not, the program continues without initializing the queue name and trigger data. This paragraph calls 1100-OPEN-REQUEST-QUEUE and 3100-READ-REQUEST-MQ to perform the actual queue operations.",
        "called_by": [],
        "calls": [
          "1100-OPEN-REQUEST-QUEUE",
          "3100-READ-REQUEST-MQ"
        ],
        "citation": [
          230,
          248
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1000-EXIT",
        "summary": null,
        "purpose": "This paragraph serves as the exit point for the 1000-INITIALIZE paragraph. It simply contains the EXIT statement, which returns control to the calling paragraph (MAIN-PARA). It does not consume any inputs, produce any outputs, implement any business logic, or handle any errors. It is a standard COBOL construct to define the end of a PERFORM THRU range.",
        "called_by": [],
        "calls": [],
        "citation": [
          249,
          254
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1100-OPEN-REQUEST-QUEUE",
        "summary": null,
        "purpose": "This paragraph opens the WebSphere MQ request queue for shared input. It moves MQOT-Q to MQOD-OBJECTTYPE of MQM-OD-REQUEST and WS-REQUEST-QNAME to MQOD-OBJECTNAME of MQM-OD-REQUEST, defining the queue object. It then computes WS-OPTIONS as MQOO-INPUT-SHARED, specifying shared input access. The MQOPEN call is then made using the connection handle (W01-HCONN-REQUEST), object descriptor (MQM-OD-REQUEST), options (WS-OPTIONS), object handle (W01-HOBJ-REQUEST), completion code (WS-COMPCODE), and reason code (WS-REASON). If the MQOPEN call is successful (WS-COMPCODE = MQCC-OK), WS-REQUEST-MQ-OPEN is set to TRUE. Otherwise, an error is logged using 9500-LOG-ERROR. The paragraph consumes WS-REQUEST-QNAME as input and produces the opened queue handle (W01-HOBJ-REQUEST) as output. The business logic involves setting the correct options for opening the queue. Error handling is performed by checking the completion code and logging an error if the queue could not be opened. This paragraph calls 9500-LOG-ERROR to log any errors encountered during the queue opening process.",
        "called_by": [],
        "calls": [
          "MQOPEN",
          "9500-LOG-ERROR"
        ],
        "citation": [
          255,
          285
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1100-EXIT",
        "summary": null,
        "purpose": "This paragraph serves as the exit point for the 1100-OPEN-REQUEST-QUEUE paragraph. It contains the EXIT statement, which returns control to the calling paragraph (1000-INITIALIZE). It does not consume any inputs, produce any outputs, implement any business logic, or handle any errors. It is a standard COBOL construct to define the end of a PERFORM THRU range.",
        "called_by": [],
        "calls": [],
        "citation": [
          286,
          291
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1200-SCHEDULE-PSB",
        "summary": null,
        "purpose": "This paragraph schedules a PSB (Program Specification Block) in IMS. It executes a DLI SCHD command with the PSB-NAME. The DIBSTAT is moved to IMS-RETURN-CODE. If the PSB is scheduled more than once, it terminates the PSB and schedules it again. If the status is OK, IMS-PSB-SCHD is set to TRUE. Otherwise, an error is logged using 9500-LOG-ERROR. This paragraph takes PSB-NAME as input and sets IMS-PSB-SCHD as output. The business logic involves scheduling the PSB and handling the case where it's scheduled more than once. Error handling is performed by checking the DIBSTAT and logging an error if the scheduling fails. This paragraph calls 9500-LOG-ERROR to log any errors encountered during the PSB scheduling process.",
        "called_by": [],
        "calls": [
          "9500-LOG-ERROR"
        ],
        "citation": [
          292,
          318
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1200-EXIT",
        "summary": null,
        "purpose": "This paragraph serves as the exit point for the 1200-SCHEDULE-PSB paragraph. It contains the EXIT statement, which returns control to the calling paragraph. It does not consume any inputs, produce any outputs, implement any business logic, or handle any errors. It is a standard COBOL construct to define the end of a PERFORM THRU range.",
        "called_by": [],
        "calls": [],
        "citation": [
          319,
          322
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "2000-MAIN-PROCESS",
        "summary": null,
        "purpose": "This paragraph is the main processing loop of the program, handling authorization requests from the message queue. It repeatedly performs 2100-EXTRACT-REQUEST-MSG to extract the request message and 5000-PROCESS-AUTH to process the authorization. The loop continues until either NO-MORE-MSG-AVAILABLE is true or WS-LOOP-END is true. After processing each message, it increments WS-MSG-PROCESSED and issues a CICS SYNCPOINT. IMS-PSB-NOT-SCHD is set to TRUE. If WS-MSG-PROCESSED exceeds WS-REQSTS-PROCESS-LIMIT, WS-LOOP-END is set to TRUE, terminating the loop. Otherwise, it calls 3100-READ-REQUEST-MQ to read the next request message. The paragraph consumes request messages from the queue and produces authorization responses and updates to IMS. The business logic involves processing each message and limiting the number of messages processed in a single execution. Error handling is not explicitly shown in this snippet, but it's likely handled within the called paragraphs. This paragraph calls 2100-EXTRACT-REQUEST-MSG, 5000-PROCESS-AUTH, and 3100-READ-REQUEST-MQ to perform the actual message processing and queue operations.",
        "called_by": [],
        "calls": [
          "2100-EXTRACT-REQUEST-MSG",
          "5000-PROCESS-AUTH",
          "3100-READ-REQUEST-MQ"
        ],
        "citation": [
          323,
          346
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "2000-EXIT",
        "summary": null,
        "purpose": "This paragraph serves as the exit point for the 2000-MAIN-PROCESS paragraph. It contains the EXIT statement, which returns control to the calling paragraph (MAIN-PARA). It does not consume any inputs, produce any outputs, implement any business logic, or handle any errors. It is a standard COBOL construct to define the end of a PERFORM THRU range.",
        "called_by": [],
        "calls": [],
        "citation": [
          347,
          350
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      }
    ],
    "error_handling": [
      {
        "condition": "WS-COMPCODE not equal to MQCC-OK",
        "action": "MOVE 'M001' to ERR-LOCATION, set ERR-CRITICAL and ERR-MQ to TRUE, move WS-COMPCODE and WS-REASON to error fields, move error message to ERR-MESSAGE, and PERFORM 9500-LOG-ERROR.",
        "citation": [
          49,
          61
        ]
      },
      {
        "condition": "STATUS-OK is false",
        "action": "MOVE 'I001' to ERR-LOCATION, set ERR-CRITICAL and ERR-IMS to TRUE, move IMS-RETURN-CODE to ERR-CODE-1, move error message to ERR-MESSAGE, and PERFORM 9500-LOG-ERROR.",
        "citation": [
          84,
          93
        ]
      }
    ],
    "sql_operations": [],
    "cics_operations": [
      {
        "command": "RETRIEVE",
        "resource": "MQTM",
        "purpose": "Retrieves the Message Queue Trigger Monitor data.",
        "citation": 15
      },
      {
        "command": "RETURN",
        "resource": null,
        "purpose": "Returns control to CICS.",
        "citation": 9
      },
      {
        "command": "SYNCPOINT",
        "resource": null,
        "purpose": "Requests a syncpoint.",
        "citation": 112
      }
    ],
    "open_questions": [
      {
        "question": "What is the structure of the authorization request message in the request queue?",
        "context": "The code reads from the request queue, but the structure of the message is not defined in the provided snippet.",
        "suggestion": "Examine the copybooks or data structures used by the 2100-EXTRACT-REQUEST-MSG paragraph."
      },
      {
        "question": "What is the structure of the authorization response message written to the response queue?",
        "context": "The code writes to the response queue, but the structure of the message is not defined in the provided snippet.",
        "suggestion": "Examine the copybooks or data structures used when sending the response."
      },
      {
        "question": "What specific IMS segments are updated during authorization processing?",
        "context": "The code interacts with IMS, but the specific segments updated are not defined in the provided snippet.",
        "suggestion": "Examine the IMS PSB and the DLI calls made during authorization processing."
      }
    ],
    "resolved_questions": [],
    "dead_code": [],
    "call_semantics": [],
    "flow_diagram": null
  },
  "saved_at": "2026-02-24T10:32:50.710519"
}