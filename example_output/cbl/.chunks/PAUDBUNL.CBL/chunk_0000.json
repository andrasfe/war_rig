{
  "batch_idx": 0,
  "total_batches": 2,
  "template": {
    "header": {
      "program_id": "PAUDBUNL",
      "file_name": "cbl/PAUDBUNL.CBL",
      "file_type": "COBOL",
      "analyzed_by": "WAR_RIG",
      "analyzed_at": "2026-02-25T15:21:52.783820",
      "iteration_count": 1,
      "final_status": null
    },
    "purpose": {
      "summary": "PAUDBUNL unloads authorization summary records from an IMS database root segment into OPFILE1 and associated detail records from child segments into OPFILE2. It initializes output files, reads sequentially through the database using GN and GNP calls until end-of-database, writing valid records while counting processed summaries. The program serves as a data extraction utility invoked via entry point DLITCBL with an IMS PCB.",
      "business_context": "Extracts pending authorization summary and detail data from IMS AUTHDB for downstream batch processing or reporting on account authorizations.",
      "program_type": "BATCH",
      "citations": [
        18,
        157,
        173,
        207,
        253,
        289
      ]
    },
    "inputs": [
      {
        "name": "PAUTBPCB",
        "io_type": "IMS_SEGMENT",
        "description": "IMS PCB for accessing AUTHDB database, providing root AUTH-SUMMARY segments via GN and child AUTH-DTL segments via GNP",
        "copybook": "PAUTBPCB",
        "citation": [
          33,
          157,
          207,
          253
        ]
      },
      {
        "name": "ROOT-UNQUAL-SSA",
        "io_type": "IMS_SEGMENT",
        "description": "Unqualified SSA for root segment access in GN call",
        "copybook": null,
        "citation": [
          210
        ]
      },
      {
        "name": "CHILD-UNQUAL-SSA",
        "io_type": "IMS_SEGMENT",
        "description": "Unqualified SSA for child segment access in GNP call",
        "copybook": null,
        "citation": [
          240
        ]
      }
    ],
    "outputs": [
      {
        "name": "OPFILE1",
        "io_type": "FILE_SEQUENTIAL",
        "description": "Sequential file containing extracted AUTH-SUMMARY root records from IMS",
        "copybook": null,
        "citation": [
          196,
          219
        ]
      },
      {
        "name": "OPFILE2",
        "io_type": "FILE_SEQUENTIAL",
        "description": "Sequential file containing extracted AUTH-DTL child records from IMS",
        "copybook": null,
        "citation": [
          247
        ]
      }
    ],
    "called_programs": [],
    "calling_context": {
      "called_by": [],
      "entry_points": [
        "DLITCBL"
      ],
      "linkage_section": [
        "PAUTBPCB"
      ]
    },
    "business_rules": [
      {
        "rule_id": "BR001",
        "description": "Write root summary record to OPFILE1 only if PA-ACCT-ID is numeric",
        "logic_summary": "After reading root segment, check PA-ACCT-ID NUMERIC before WRITE",
        "conditions": [
          "PA-ACCT-ID IS NUMERIC"
        ],
        "citation": [
          219
        ]
      },
      {
        "rule_id": "BR002",
        "description": "Continue child segment loop until GE status (end of qualifying children for current parent)",
        "logic_summary": "PERFORM 3000 until WS-END-OF-CHILD-SEG = 'Y' set on GE",
        "conditions": [
          "PAUT-PCB-STATUS = 'GE'",
          "WS-END-OF-CHILD-SEG = 'Y'"
        ],
        "citation": [
          214,
          250
        ]
      },
      {
        "rule_id": "BR003",
        "description": "Terminate root loop on GB status (end of database)",
        "logic_summary": "Set WS-END-OF-ROOT-SEG = 'Y' on GB and exit loop",
        "conditions": [
          "PAUT-PCB-STATUS = 'GB'"
        ],
        "citation": [
          220
        ]
      }
    ],
    "data_flow": {
      "reads_from": [
        {
          "source": "PAUTBPCB",
          "fields_used": [
            "PAUT-PCB-STATUS",
            "PAUT-SEG-LEVEL",
            "PAUT-SEG-NAME",
            "PAUT-KEYFB",
            "PA-ACCT-ID"
          ],
          "citation": [
            187,
            195,
            223,
            239,
            243,
            266,
            273,
            279
          ]
        }
      ],
      "writes_to": [
        {
          "destination": "OPFIL1-REC",
          "fields_written": [
            "PENDING-AUTH-SUMMARY"
          ],
          "citation": [
            219
          ]
        },
        {
          "destination": "OPFIL2-REC",
          "fields_written": [
            "CHILD-SEG-REC",
            "PENDING-AUTH-DETAILS"
          ],
          "citation": [
            247
          ]
        }
      ],
      "transforms": [
        {
          "input_field": "PENDING-AUTH-SUMMARY",
          "output_field": "OPFIL1-REC",
          "transformation_description": "Direct MOVE of read IMS root segment to output record before conditional WRITE",
          "citation": [
            219
          ]
        },
        {
          "input_field": "PENDING-AUTH-DETAILS",
          "output_field": "CHILD-SEG-REC",
          "transformation_description": "Direct MOVE of read IMS child segment to output record before WRITE",
          "citation": [
            246
          ]
        },
        {
          "input_field": "PA-ACCT-ID",
          "output_field": "ROOT-SEG-KEY",
          "transformation_description": "MOVE from root segment field to key area after initialization",
          "citation": [
            219
          ]
        }
      ]
    },
    "copybooks_used": [
      {
        "copybook_name": "PAUTBPCB",
        "purpose": "Defines IMS PCB structure including status, segment name, level, key feedback",
        "location": "LINKAGE",
        "citation": 33
      }
    ],
    "paragraphs": [
      {
        "paragraph_name": "PAUDBUNL",
        "summary": null,
        "purpose": "This is the program entry point paragraph, primarily serving as the PROGRAM-ID declaration point. It does not consume any inputs directly but establishes the program's identity. No outputs are produced here. There is no business logic, decisions, or error handling implemented. It does not call any other paragraphs or programs directly, but the overall program flow starts here implicitly. The paragraph's role is minimal, acting as a label for the program's starting address. [Note: Minimal content based on outline; likely contains procedure division header.]",
        "called_by": [],
        "calls": [],
        "citation": [
          18,
          18
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "MAIN-PARA",
        "summary": null,
        "purpose": "This is the main orchestration paragraph that controls the overall program flow after the DLITCBL entry point. It receives the IMS PCB (PAUTBPCB) via USING in the ENTRY statement, consuming it as the primary input for database access. It produces no direct outputs but orchestrates writing to OPFILE1 and OPFILE2 via subordinate paragraphs. The business logic implements a top-level sequence: initialize files and variables, loop through root segments until end-of-database, then close files. No explicit error handling here, but delegates to initializers which check statuses. It calls 1000-INITIALIZE THRU 1000-EXIT for setup, repeatedly performs 2000-FIND-NEXT-AUTH-SUMMARY THRU 2000-EXIT UNTIL WS-END-OF-ROOT-SEG = 'Y' for unloading loop, and 4000-FILE-CLOSE THRU 4000-EXIT for termination, ensuring orderly processing of all authorizations.",
        "called_by": [
          "PAUDBUNL"
        ],
        "calls": [
          "1000-INITIALIZE",
          "2000-FIND-NEXT-AUTH-SUMMARY",
          "4000-FILE-CLOSE"
        ],
        "citation": [
          157,
          172
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1000-INITIALIZE",
        "summary": null,
        "purpose": "This paragraph handles program initialization, including date acceptance, display of start messages, and opening output files OPFILE1 and OPFILE2. It consumes no external data inputs but reads file status codes WS-OUTFL1-STATUS and WS-OUTFL2-STATUS after OPEN. It produces initialized files ready for writing and display output to console. Business logic includes validating OPEN status: if not spaces or '00', display error and PERFORM 9999-ABEND. There are 5 decision points across two IF blocks for each file's status check. Error handling is explicit: abend on open failure with status display. It calls 9999-ABEND twice on errors but no successful path calls; control returns via THRU to 1000-EXIT.",
        "called_by": [
          "MAIN-PARA"
        ],
        "calls": [
          "9999-ABEND"
        ],
        "citation": [
          173,
          202
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "1000-EXIT",
        "summary": null,
        "purpose": "This is the exit paragraph for 1000-INITIALIZE, serving solely to return control to the calling paragraph using EXIT. It consumes no inputs and produces no outputs or modifications. There is no business logic, conditions, error handling, or calls. Its role is to cleanly terminate the initialization routine after successful or checked operations.",
        "called_by": [
          "1000-INITIALIZE"
        ],
        "calls": [],
        "citation": [
          203,
          206
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "2000-FIND-NEXT-AUTH-SUMMARY",
        "summary": null,
        "purpose": "This complex paragraph orchestrates reading the next root AUTH-SUMMARY segment from IMS and processing its children. It consumes IMS PCB via CBLTDLI GN call into PENDING-AUTH-SUMMARY using ROOT-UNQUAL-SSA, reading PAUT-PCB-STATUS and related fields. It produces writes to OPFILE1-REC (after MOVE from PENDING-AUTH-SUMMARY) and initializes counters WS-NO-SUMRY-READ, WS-AUTH-SMRY-PROC-CNT. Business logic includes 7 decision points: check PCB status SPACES (process record, init keys, conditional WRITE if PA-ACCT-ID NUMERIC, then child loop), GB (set end-of-root flag), else error/abend. The child PERFORM loop until WS-END-OF-CHILD-SEG='Y' unloads details. Error handling: display status/KEYFB and 9999-ABEND on non-SPACES/GB. Calls CBLTDLI for GN, 3000-FIND-NEXT-AUTH-DTL THRU 3000-EXIT for children, 9999-ABEND on failure.",
        "called_by": [
          "MAIN-PARA"
        ],
        "calls": [
          "3000-FIND-NEXT-AUTH-DTL",
          "9999-ABEND"
        ],
        "citation": [
          207,
          247
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "2000-EXIT",
        "summary": null,
        "purpose": "This is the exit paragraph for 2000-FIND-NEXT-AUTH-SUMMARY, performing EXIT to return control after processing a root segment and its children. No inputs consumed, no outputs produced, no logic or errors handled, no calls made. Role is to terminate the root processing iteration cleanly.",
        "called_by": [
          "2000-FIND-NEXT-AUTH-SUMMARY"
        ],
        "calls": [],
        "citation": [
          248,
          252
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "3000-FIND-NEXT-AUTH-DTL",
        "summary": null,
        "purpose": "This paragraph reads the next child AUTH-DTL segment under the current root using GNP CBLTDLI call into PENDING-AUTH-DETAILS with CHILD-UNQUAL-SSA. It consumes IMS PCB status and data, modifying WS-NO-SUMRY-READ, WS-AUTH-SMRY-PROC-CNT, CHILD-SEG-REC (via MOVE), and writes to OPFIL2-REC. Business logic has 4 decision points: SPACES (increment counters, MOVE and WRITE), GE (set WS-END-OF-CHILD-SEG='Y', display), else error/abend with display. Error handling: display status/KEYFB and 9999-ABEND on non-SPACES/GE, then init PCB status. No subordinate calls except implicit CBLTDLI; invoked in loop from 2000.",
        "called_by": [
          "2000-FIND-NEXT-AUTH-SUMMARY"
        ],
        "calls": [
          "9999-ABEND"
        ],
        "citation": [
          253,
          284
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "3000-EXIT",
        "summary": null,
        "purpose": "Exit paragraph for 3000-FIND-NEXT-AUTH-DTL, uses EXIT to return after single child read/write or end/error. No inputs/outputs/logic/error handling/calls. Ensures loop continuation check.",
        "called_by": [
          "3000-FIND-NEXT-AUTH-DTL"
        ],
        "calls": [],
        "citation": [
          285,
          288
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "4000-FILE-CLOSE",
        "summary": null,
        "purpose": "This termination paragraph closes output files OPFILE1 and OPFILE2, consuming their status codes WS-OUTFL1-STATUS and WS-OUTFL2-STATUS. It produces closed files and display messages. Business logic: two IF checks per close (spaces or '00' continue, else display error but NO ABEND). 2 decision points total, no writes or loops. Error handling: logs close errors via DISPLAY but continues without abend. No calls made; displays 'CLOSING THE FILE'.",
        "called_by": [
          "MAIN-PARA"
        ],
        "calls": [],
        "citation": [
          289,
          304
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      },
      {
        "paragraph_name": "4000-EXIT",
        "summary": null,
        "purpose": "Exit for 4000-FILE-CLOSE, simple EXIT to return after closes. No inputs/outputs/logic.",
        "called_by": [
          "4000-FILE-CLOSE"
        ],
        "calls": [],
        "citation": [
          305,
          307
        ],
        "outgoing_calls": [],
        "incoming_calls": [],
        "is_dead_code": false,
        "dead_code_reason": null,
        "metadata": null
      }
    ],
    "error_handling": [
      {
        "condition": "WS-OUTFL1-STATUS NOT = SPACES OR '00' on OPEN",
        "action": "DISPLAY error, PERFORM 9999-ABEND",
        "citation": [
          187
        ]
      },
      {
        "condition": "WS-OUTFL2-STATUS NOT = SPACES OR '00' on OPEN",
        "action": "DISPLAY error, PERFORM 9999-ABEND",
        "citation": [
          195
        ]
      },
      {
        "condition": "PAUT-PCB-STATUS NOT = SPACES AND NOT 'GB' on GN",
        "action": "DISPLAY status and KEYFB, PERFORM 9999-ABEND",
        "citation": [
          223
        ]
      },
      {
        "condition": "PAUT-PCB-STATUS NOT = SPACES AND NOT 'GE' on GNP",
        "action": "DISPLAY status and KEYFB, PERFORM 9999-ABEND",
        "citation": [
          266
        ]
      },
      {
        "condition": "WS-OUTFL1-STATUS NOT = SPACES OR '00' on CLOSE",
        "action": "DISPLAY error (no abend)",
        "citation": [
          293
        ]
      },
      {
        "condition": "WS-OUTFL2-STATUS NOT = SPACES OR '00' on CLOSE",
        "action": "DISPLAY error (no abend)",
        "citation": [
          300
        ]
      }
    ],
    "sql_operations": [],
    "cics_operations": [],
    "open_questions": [
      {
        "question": "Definition and content of 9999-ABEND paragraph",
        "context": "Not provided in AST; referenced multiple times for error termination",
        "suggestion": "Include AST snippet for 9999-ABEND and 9999-EXIT"
      },
      {
        "question": "Exact copybook names and locations for FUNC-GN, FUNC-GNP, PENDING-AUTH-SUMMARY, etc.",
        "context": "Inferred from usage but not explicitly COPY statements in provided AST",
        "suggestion": "Provide WORKING-STORAGE and FILE sections"
      },
      {
        "question": "Full definition of WS-END-OF-ROOT-SEG and related flags",
        "context": "Used for loop control but initialization not shown",
        "suggestion": "Include variable declarations"
      }
    ],
    "resolved_questions": [],
    "dead_code": [],
    "call_semantics": [],
    "flow_diagram": null
  },
  "saved_at": "2026-02-25T08:21:52.784830"
}