"""Protocol and base types for sampling strategies.

This module defines the SamplingStrategy protocol and the SourceWindow
dataclass used by all sampling strategies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Protocol, runtime_checkable

if TYPE_CHECKING:
    from war_rig.sampling.analyzer import RelevanceHints
    from war_rig.sampling.context import SamplingContext


@dataclass
class SourceWindow:
    """A window of source code lines to include in the sample.

    Represents a contiguous range of lines in the source code that
    should be included in the final sample. Multiple windows are
    generated by strategies and then merged by the WindowComposer.

    Attributes:
        start_line: Starting line number (1-indexed, inclusive).
        end_line: Ending line number (1-indexed, inclusive).
        reason: Human-readable explanation of why this window was selected.
        strategy_name: Name of the strategy that generated this window.
        relevance_score: Score from 0.0 to 1.0 indicating relevance.
            Higher scores are prioritized when budget is limited.

    Example:
        >>> window = SourceWindow(
        ...     start_line=230,
        ...     end_line=250,
        ...     reason="Lines around cited line 240",
        ...     strategy_name="line_citation",
        ...     relevance_score=1.0,
        ... )
        >>> window.line_count
        21
    """

    start_line: int
    end_line: int
    reason: str
    strategy_name: str
    relevance_score: float

    def __post_init__(self) -> None:
        """Validate window bounds."""
        if self.start_line < 1:
            raise ValueError(f"start_line must be >= 1, got {self.start_line}")
        if self.end_line < self.start_line:
            raise ValueError(
                f"end_line ({self.end_line}) must be >= start_line ({self.start_line})"
            )
        if not 0.0 <= self.relevance_score <= 1.0:
            raise ValueError(
                f"relevance_score must be between 0.0 and 1.0, got {self.relevance_score}"
            )

    @property
    def line_count(self) -> int:
        """Number of lines in this window.

        Returns:
            Count of lines from start_line to end_line inclusive.
        """
        return self.end_line - self.start_line + 1

    def overlaps(self, other: "SourceWindow") -> bool:
        """Check if this window overlaps with another.

        Two windows overlap if they share any lines, including adjacent
        windows (e.g., end_line of one equals start_line of another).

        Args:
            other: Another SourceWindow to check overlap with.

        Returns:
            True if the windows overlap or are adjacent.
        """
        # Windows overlap if neither is entirely before or after the other
        # We consider adjacent windows (off by 1) as overlapping for merging
        return not (
            self.end_line < other.start_line - 1
            or other.end_line < self.start_line - 1
        )

    def merge(self, other: "SourceWindow") -> "SourceWindow":
        """Merge this window with another overlapping window.

        Creates a new window spanning both windows, taking the higher
        relevance score and combining the reasons.

        Args:
            other: Another SourceWindow to merge with.

        Returns:
            New SourceWindow spanning both input windows.

        Raises:
            ValueError: If the windows do not overlap.
        """
        if not self.overlaps(other):
            raise ValueError("Cannot merge non-overlapping windows")

        # Determine which strategy to credit (take higher relevance or first alphabetically)
        if self.relevance_score > other.relevance_score:
            primary_strategy = self.strategy_name
            primary_reason = self.reason
        elif other.relevance_score > self.relevance_score:
            primary_strategy = other.strategy_name
            primary_reason = other.reason
        else:
            # Same score, take first alphabetically for consistency
            if self.strategy_name <= other.strategy_name:
                primary_strategy = self.strategy_name
                primary_reason = self.reason
            else:
                primary_strategy = other.strategy_name
                primary_reason = other.reason

        return SourceWindow(
            start_line=min(self.start_line, other.start_line),
            end_line=max(self.end_line, other.end_line),
            reason=primary_reason,
            strategy_name=primary_strategy,
            relevance_score=max(self.relevance_score, other.relevance_score),
        )

    def clamp(self, max_line: int) -> "SourceWindow":
        """Return a new window clamped to valid line bounds.

        Args:
            max_line: Maximum valid line number.

        Returns:
            New SourceWindow with bounds clamped to [1, max_line].
        """
        return SourceWindow(
            start_line=max(1, self.start_line),
            end_line=min(max_line, self.end_line),
            reason=self.reason,
            strategy_name=self.strategy_name,
            relevance_score=self.relevance_score,
        )


@runtime_checkable
class SamplingStrategy(Protocol):
    """Protocol for source code sampling strategies.

    Each strategy examines the relevance hints and context to determine
    which portions of source code are most relevant for the current
    CLARIFICATION or CHROME ticket.

    Strategies have a priority (lower = higher priority) that determines
    the order in which they're applied. When the token budget is limited,
    higher-priority strategies get their windows included first.

    Example implementation:
        class MyStrategy:
            @property
            def name(self) -> str:
                return "my_strategy"

            @property
            def priority(self) -> int:
                return 50

            def can_apply(self, hints: RelevanceHints, context: SamplingContext) -> bool:
                return bool(hints.my_hints)

            def generate_windows(
                self,
                hints: RelevanceHints,
                context: SamplingContext,
            ) -> list[SourceWindow]:
                windows = []
                for hint in hints.my_hints:
                    windows.append(SourceWindow(...))
                return windows
    """

    @property
    def name(self) -> str:
        """Name of this strategy for logging and attribution.

        Returns:
            A short, descriptive name like "line_citation".
        """
        ...

    @property
    def priority(self) -> int:
        """Priority of this strategy (lower = higher priority).

        Used to determine the order strategies are applied and which
        windows are included when budget is limited.

        Returns:
            Priority value (1 = highest priority, 99 = lowest).
        """
        ...

    def can_apply(
        self,
        hints: "RelevanceHints",
        context: "SamplingContext",
    ) -> bool:
        """Check if this strategy can be applied given the hints.

        Args:
            hints: Extracted relevance hints from questions/tickets.
            context: Full sampling context.

        Returns:
            True if this strategy has hints to work with.
        """
        ...

    def generate_windows(
        self,
        hints: "RelevanceHints",
        context: "SamplingContext",
    ) -> list[SourceWindow]:
        """Generate source windows based on hints.

        Args:
            hints: Extracted relevance hints.
            context: Full sampling context including source code.

        Returns:
            List of SourceWindow objects to include in the sample.
        """
        ...
